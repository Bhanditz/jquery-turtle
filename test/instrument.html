<script src="lib/qunit.js"></script>
<link href="lib/qunit.css" rel="stylesheet">
<script src="lib/jquery.js"></script>
<script src="../jquery-turtle.js"></script>
<body>
<div id="qunit"></div>
<script>
function setupFakeAudioContext() {
  window.AudioContext = (function() {
    var interval = 1/16,
        methodlog = [],
        ocounts = {};
    function makeLoggingMethod(oname, fname) {
      return function() {
        var mname = oname + '.' + fname;
        methodlog.push(mname);
      }
    }
    function makeLoggingObject(oname) {
      if (!ocounts[oname]) {
        ocounts[oname] = 0;
      }
      ocounts[oname] += 1;
      oname += ocounts[oname];
      return {
        gain: {
          setValueAtTime: function() {},
          linearRampToValueAtTime: function() {},
          setTargetAtTime: function() {},
          cancelScheduledValues: function() {},
          value: null
        },
        frequency: {
          value: null
        },
        Q: {
          value: null
        },
        connect: makeLoggingMethod(oname, 'connect'),
        disconnect: makeLoggingMethod(oname, 'disconnect'),
        start: makeLoggingMethod(oname, 'start'),
        stop: makeLoggingMethod(oname, 'stop')
      };
    }
    function makeCtor(oname) {
      return function() {
        return makeLoggingObject(oname);
      };
    }
    function AudioContext() {
      var ac = {
        destination: null,
        currentTime: 0,
        createGain: makeCtor('gain'),
        createDynamicsCompressor: makeCtor('dcn'),
        createBiquadFilter: makeCtor('filter'),
        createOscillator: makeCtor('osc')
      };
      function advance() {
        ac.currentTime += interval;
        setTimeout(advance, Math.floor(1000 * interval));
      }
      setTimeout(advance, Math.floor(1000 * interval));
      return ac;
    }
    AudioContext.resetTestLog = function() {
      methodlog.length = 0;
      ocounts = {};
    }
    AudioContext.methodlog = methodlog;
    return AudioContext;
  })();
}
function setupFakeTimer(msLimit, whendone) {
  if (!msLimit) msLimit = 10 * 60 * 1000;
  if (!window.originalSetTimeout) {
    window.originalSetTimeout = window.setTimeout;
  }
  var ost = window.originalSetTimeout;
  var timeouts = [];
  var now = 0;
  var currentTimeout = 0;
  function nextEvent() {
    currentTimeout = null;
    var minTime = Infinity, index = -1, fn;
    for (var j = 0; j < timeouts.length; ++j) {
      if (timeouts[j].time < minTime) {
        minTime = timeouts[j].time;
        index = j;
      }
    }
    if (index >= 0) {
      fn = timeouts[index].fn;
      timeouts.splice(index, 1);
      now = minTime;
      if (now < msLimit) {
        fn();
      }
    } else {
      // No timeouts scheduled? Advance by a second to zap to the end.
      now += 1000;
    }
    if (now < msLimit) {
      currentTimeout = ost(nextEvent, 0);
    } else {
      if (whendone) { whendone(); }
      window.setTimeout = ost;
    }
  }
  window.setTimeout = function(fn, num) {
    if (isNaN(num) || Math.floor(num) != num) {
      console.trace('non-integer delay', num);
    }
    var when = now + Math.max(0, num);
    if (!isNaN(when)) {
      timeouts.push({time: when, fn: fn});
      if (!currentTimeout) {
        currentTimeout = ost(nextEvent, 0);
      }
    }
  }
  window.currentTick = function() { return now; }
}
setupFakeTimer();
setupFakeAudioContext();

eval($.turtle());

module("Test of the Instrument class.");
asyncTest("Plays a song with an Instrument.", function() {
  // reset methodlog
  AudioContext.resetTestLog();
  var ins = new Instrument(),
      notelog = [];
  ins.noteon = function(mid) { notelog.push('on' + mid); }
  ins.noteoff = function(mid) { notelog.push('off' + mid); }
  // Play 16 tones (13 beats) from stairway.
  ins.play("F_Acf [gE]cAg [a_E]cAa [dD]");
  ins.done(function() {
    equal(AudioContext.methodlog[0], "gain1.connect");
    // We should have hooked up, started, and stopped the 16th tone.
    ok(AudioContext.methodlog.indexOf('osc16.connect') > 0);
    ok(AudioContext.methodlog.indexOf('osc16.start') > 0);
    ok(AudioContext.methodlog.indexOf('osc16.stop') > 0);
    // And there should be no 17th tone.
    ok(AudioContext.methodlog.indexOf('osc17.start') < 0);
    // Now test that we got all the callbacks, in order.
    deepEqual(notelog, [
        "on65", "off65", "on68", "off68",
        "on72", "off72", "on77", "off77",
        "on79", "on64", "off79", "off64", // chord
        "on72", "off72", "on68", "off68",
        "on79", "off79",
        "on80", "on63", "off80", "off63", // chord
        "on72", "off72", "on68", "off68",
        "on80", "off80",
        "on74", "on62", "off74", "off62"  // chord
    ]);
    start();
  });
});

asyncTest("Test staccato timing.", function() {
  AudioContext.resetTestLog();
  var startTick = currentTick(),
      ins = new Instrument(),
      notelog = [];
  ins.noteon = function(mid) {
    notelog.push('on' + mid + '-' + (currentTick() - startTick));
  }
  ins.noteoff = function(mid) {
    notelog.push('off' + mid + '-' + (currentTick() - startTick));
  }
  // Play some staccato tones.
  ins.play({tempo:120},"C.c.cC");
  ins.done(function() {
    equal(AudioContext.methodlog[0], "gain1.connect");
    // We should have hooked up, started, and stopped the 4th tone.
    ok(AudioContext.methodlog.indexOf('osc4.connect') > 0);
    ok(AudioContext.methodlog.indexOf('osc4.start') > 0);
    ok(AudioContext.methodlog.indexOf('osc4.stop') > 0);
    // And there should be no 5th tone.
    ok(AudioContext.methodlog.indexOf('osc5.start') < 0);
    // Now test that we got all the callbacks, in order.
    deepEqual(notelog, [            // Default tempo: 120 = 500ms beats.
        "on60-0", "off60-500",      // Full beat C4.
        "on72-500", "off72-562",    // Staccato C5.
        "on72-1000", "off72-1062",  // Staccato C5.
        "on60-1500", "off60-2000"   // Full beat C4 again.
    ]);
    start();
  });
});

asyncTest("Test staccato timing.", function() {
  AudioContext.resetTestLog();
  var startTick = currentTick(),
      ins = new Instrument(),
      notelog = [];
  ins.noteon = function(mid) {
    notelog.push('on' + mid + '-' + (currentTick() - startTick));
  }
  ins.noteoff = function(mid) {
    notelog.push('off' + mid + '-' + (currentTick() - startTick));
  }
  // Play some staccato tones.
  ins.play({tempo:120},"C.c.cC");
  ins.done(function() {
    equal(AudioContext.methodlog[0], "gain1.connect");
    // We should have hooked up, started, and stopped the 4th tone.
    ok(AudioContext.methodlog.indexOf('osc4.connect') > 0);
    ok(AudioContext.methodlog.indexOf('osc4.start') > 0);
    ok(AudioContext.methodlog.indexOf('osc4.stop') > 0);
    // And there should be no 5th tone.
    ok(AudioContext.methodlog.indexOf('osc5.start') < 0);
    // Now test that we got all the callbacks, in order.
    deepEqual(notelog, [            // Default tempo: 120 = 500ms beats.
        "on60-0", "off60-500",      // Full beat C4.
        "on72-500", "off72-562",    // Staccato C5.
        "on72-1000", "off72-1062",  // Staccato C5.
        "on60-1500", "off60-2000"   // Full beat C4 again.
    ]);
    start();
  });
});
</script>

